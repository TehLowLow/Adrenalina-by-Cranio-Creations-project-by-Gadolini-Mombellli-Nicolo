package it.polimi.se2019.RMI.Server;

import it.polimi.se2019.Controller.Data.MapBuilders.*;
import it.polimi.se2019.RMI.Client.ClientInterface;
import it.polimi.se2019.View.*;
import it.polimi.se2019.Model.*;

import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.ArrayList;
import java.util.Hashtable;

import static java.lang.Thread.sleep;

/**
 * This is the main RMI class responsible of managing network, collecting usernames and passwords, storing the datas
 * and communication with every client.
 */


public class Server extends Thread implements ServerInterface {


    /**
     * COntains all the players that are logging in before the start of the game.
     */
    static ArrayList<Player> players;

    /**
     *Keeps track of every new connection from any new unregistered user.
     */
    public static Hashtable logInTable = new Hashtable();

    /**
     * Is the port where the server starts his registry.
     */
    static final int PORT = 2000;

    /**
     * Each new unregistered user gets a dedicated port.
     * clientPorts gets updated by adding 500 each time a new user registers.
     * This gives each server instance capability of registering more than 120 individual users
     * (assuming that RMI can interact with 65.536 ports and skipping the first 4.000).
     */
    static int clientPorts = 4000;


    /**
     * Keeps track of all the registeredusers and their relative port.
     * This is done to allow a user that disconnects to restore connection on the same initial port, avoiding a possible
     * problem generated by continuous disconnection that might increase too much the value of clientPorts.
     */
    static Hashtable coccupiedClientPorts = new Hashtable();

    public static void main(String[] args) {

        players = new ArrayList<>();

        Thread s = new Server();
        s.run();

    }


    @Override
    public synchronized void run() {

        serverInit();

    }


//----------------------------------------------------------------------------------------------------

    /**
     * Starts a server registry where all the clients will be pushing messages.
     */

    private void serverInit() {

        try { //avvio il server registry

            String nome = "Server";
            Server server = new Server();
            ServerInterface stub = (ServerInterface) UnicastRemoteObject.exportObject(server, PORT);
            Registry registry = LocateRegistry.createRegistry(PORT);
            registry.rebind(nome, stub);
            System.out.println("Server online listening on port " + PORT);


        } catch (Exception e) {
            System.err.println("Errore di init registry!");
            e.printStackTrace();

        }
    }

    //----------------------------------------------------------------------------------------------------

    /**
     * Is the validation system that checks the login data from every user, and decides if they are a new user, a
     * disconnected user that wants to reconnect or a user that is trying to double-connect from two separate clients with
     * the same username and password.
     * @param user is the username the player wants to use, and it must be unique.
     * @param pass is the player's password used for validation purposes
     * @return true if the player is granted access.
     */

    public synchronized boolean logIn(String user, String pass) {

        String verify;
        CheckTable checkTable = new CheckTable();

        if (logInTable.get(user) == null) {

            logInTable.put(user, pass);
            coccupiedClientPorts.put(user, clientPorts);
            clientPorts = clientPorts + 500;

            Player player = new Player();
            player.setNickname(user);

            players.add(player);


            System.out.println("Aggiunto" + " " + user);

            if (players.size() == 3) {
                CheckAlive checkAlive = new CheckAlive(30, players);
                checkAlive.check();
            }
            return true;

        } else if (checkTable.checker(user, players)) {

            return false; //Il player sta tentando di accedere due volte

        } else {

            verify = (String) logInTable.get(user); //il player si è disconnesso e vuole riaccedere
            if (verify.equals(pass)) {

                Player player = new Player();
                player.setNickname(user);
                player.setConnectionAlive(true);
                players.add(player);
                if (players.size() == 3) {
                    CheckAlive checkAlive = new CheckAlive(30, players);
                    checkAlive.check();
                }
                return true;
            }
        }

        return false;
    }
    //TODO Issue: Il login non controlla il valore dei caratteri inseriti, percui unutente che si registra con "Nome"
    // e uno che si registra con "Nome(spazio)" verranno trattati come due user con nomi tecnicamente diversi ma in
    // pratica poco chiari all' utente.
    // esempio: "Lollo" e "Lollo " hanno lunghezza diversa, il secondo ha un carattere diverso dal primo però non
    // sarà distinguibile a terminale
    // Il login inoltre non verifica che la password non sia vuota.
//----------------------------------------------------------------------------------------------------


    /**
     * Returns the associated static port of a user, allowing them to load a registry in that same port for callback
     * purposes.
     * @param nick is the name of the player that needs his port.
     * @return the port.
     */
    public synchronized int firstFreePort(String nick) {

        return (int) coccupiedClientPorts.get((nick));
    }


//----------------------------------------------------------------------------------------------------

    /**
     * IS the main method that looks up for the client callback registry and establishes connection.
     * @param nick is the player to connect to.
     * @param port is the port where to look for the client's registry.
     */
    private synchronized void callBack(String nick, int port) {

        ClientInterface client;

        try {
            Registry registry = LocateRegistry.getRegistry(port);
            client = (ClientInterface) registry.lookup(nick);
            client.serverMessage("Ciao " + nick +", benvenuto sul server di Adrenalina");
        } catch (Exception e) {
            System.err.println("Errore callBack");
        }
    }


//----------------------------------------------------------------------------------------------------

    /**
     * Is the method that is called from the client, to notify the server that the registry is ready to be contacted.
     * @param nick is the name of the client to call back.
     * @param port is the port number for registry lookup.
     */
    public synchronized void initCallback(String nick, int port) {

        callBack(nick, port);

    }

//----------------------------------------------------------------------------------------------------


    @Deprecated
    public synchronized void login(String nickname) {

        Player player = new Player();
        player.setNickname(nickname);
        players.add(player);
        System.out.println("Si è aggiunto il giocatore " + nickname);
        System.out.println("Per ora i giocatori sono:");

        for (Player giocatore : players) {

            System.out.println(giocatore.getNickname());

        }

        if (players.size() == 3) {
            CheckAlive checkAlive = new CheckAlive(30, players);
            checkAlive.check();
        }

        System.out.println("-----");
    }


//----------------------------------------------------------------------------------------------------

    @Deprecated
    public synchronized void ping(String nickname) {

        //System.out.println(nickname + " è ancora vivo.");
        for (Player player : players) {
            if (player.getNickname().equals(nickname)) {
                player.setConnectionAlive(true);
            }
        }
    }

//----------------------------------------------------------------------------------------------------

    @Deprecated
    public Map buildMap(String map) {  //da pensare con dual channel rmi

        if (map.equals("1")) {
            return new Map1Builder().build();
        }

        if (map.equals("2")) {
            return new Map2Builder().build();
        }

        if (map.equals("3")) {
            return new Map3Builder().build();
        }

        if (map.equals("4")) {

            return new Map4Builder().build();
        }
        return null;
    }
}