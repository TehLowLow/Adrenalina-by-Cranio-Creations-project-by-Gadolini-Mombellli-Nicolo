package it.polimi.se2019.Network.Deprecated;

import it.polimi.se2019.Model.*;

import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.ArrayList;
import java.util.Hashtable;

import static java.lang.Thread.sleep;

/**
 * This is the main RMI class responsible of managing network, collecting usernames and passwords, storing the datas
 * and communication with every client.
 */


public class Server extends Thread implements ServerInterface {


    /**
     * Contains all the players that are logging in before the start of the game.
     */
    static ArrayList<Player> players = new ArrayList<>();

    static ArrayList<ClientInterface> clients = new ArrayList<>();
    ;

    /**
     * Keeps track of every new connection from any new unregistered user.
     */
    public static Hashtable logInTable = new Hashtable();

    /**
     * Is the port where the server starts his registry.
     */
    static final int PORT = 2000;

    /**
     * Each new unregistered user gets a dedicated port.
     * clientPorts gets updated by adding 500 each time a new user registers.
     * This gives each server instance capability of registering more than 120 individual users
     * (assuming that RMI can interact with 65.536 ports and skipping the first 4.000).
     */
    static int clientPorts = 4000;


    /**
     * Keeps track of all the registeredusers and their relative port.
     * This is done to allow a user that disconnects to restore connection on the same initial port, avoiding a possible
     * problem generated by continuous disconnection that might increase too much the value of clientPorts.
     */
    static Hashtable coccupiedClientPorts = new Hashtable();

    public static void main(String[] args) {

        Server s = new Server();
        s.run();

    }


    @Override
    public synchronized void run() {

        serverInit(this);

    }


//----------------------------------------------------------------------------------------------------

    /**
     * Starts a server registry where all the clients will be pushing messages.
     */

    private void serverInit(Server server) {

        try { //avvio il server registry

            String nome = "Server";
            ServerInterface stub = (ServerInterface) UnicastRemoteObject.exportObject(server, PORT);
            Registry registry = LocateRegistry.createRegistry(PORT);
            registry.rebind(nome, stub);
            System.out.println("Server online listening on port " + PORT);


        } catch (Exception e) {
            System.err.println("Errore di init registry!");
            e.printStackTrace();

        }
    }

    //Passo in RMI.Clientrmi

    //----------------------------------------------------------------------------------------------------

    /**
     * Is the validation system that checks the login data from every user, and decides if they are a new user, a
     * disconnected user that wants to reconnect or a user that is trying to double-connect from two separate clients with
     * the same username and password.
     *
     * @param user is the username the player wants to use, and it must be unique.
     * @param pass is the player's password used for validation purposes
     * @return true if the player is granted access.
     */

    public synchronized boolean logIn(String user, String pass) {

        String verify;
        CheckTable checkTable = new CheckTable();

        if (logInTable.get(user) == null) {

            logInTable.put(user, pass);
            coccupiedClientPorts.put(user, clientPorts);
            clientPorts = clientPorts + 500;

            Player player = new Player();
            player.setNickname(user);

            players.add(player);


            System.out.println("Aggiunto" + " " + user);

            if (players.size() == 3) {

               // Lobby lobby = new Lobby();
               // lobby.start();

            }
            return true;

        } else if (checkTable.checker(user, players)) {

            return false; //Il player sta tentando di accedere due volte

        } else {

            verify = (String) logInTable.get(user); //il player si è disconnesso e vuole riaccedere
            if (verify.equals(pass)) {

                Player player = new Player();
                player.setNickname(user);
                player.setConnectionAlive(true);
                players.add(player);
                if (players.size() == 3) {
                   // Lobby lobby = new Lobby();
                   //  lobby.start();
                }
                return true;
            }
        }

        return false;
    }
    //TODO Issue: Il login non controlla il valore dei caratteri inseriti, percui unutente che si registra con "Nome"
    // e uno che si registra con "Nome(spazio)" verranno trattati come due user con nomi tecnicamente diversi ma in
    // pratica poco chiari all' utente.
    // esempio: "Lollo" e "Lollo " hanno lunghezza diversa, il secondo ha un carattere diverso dal primo però non
    // sarà distinguibile a terminale
    // Il login inoltre non verifica che la password non sia vuota.
//----------------------------------------------------------------------------------------------------


    /**
     * Returns the associated static port of a user, allowing them to load a registry in that same port for callback
     * purposes.
     *
     * @param nick is the name of the player that needs his port.
     * @return the port.
     */
    public synchronized int firstFreePort(String nick) {

        return (int) coccupiedClientPorts.get((nick));
    }


//----------------------------------------------------------------------------------------------------

    /**
     * Is the method that is called from the client, to notify the server that the registry is ready to be contacted.
     *
     * @param nick is the name of the client to call back.
     * @param port is the port number for registry lookup.
     */
    public synchronized void initCallback(String nick, int port) {

        callBack(nick, port);

    }


//----------------------------------------------------------------------------------------------------

    /**
     * IS the main method that looks up for the client callback registry and establishes connection.
     *
     * @param nick is the player to connect to.
     * @param port is the port where to look for the client's registry.
     */
    public synchronized void callBack(String nick, int port) {

        ClientInterface client;

        try {
            Registry registry = LocateRegistry.getRegistry(port);
            client = (ClientInterface) registry.lookup(nick);
            client.serverMessage("Ciao " + nick + ", benvenuto sul server di Adrenalina"); //debug
            clients.add(client);//trasforma in hash
        } catch (Exception e) {
            System.err.println("Errore callBack");
            e.printStackTrace();
        }
    }

//TODO Modificare per creare Hashtable di player,client



//----------------------------------------------------------------------------------------------------

}